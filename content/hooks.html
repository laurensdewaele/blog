<h1 id="cementing-knowledge-of-react-hooks">
  Cementing knowledge of React Hooks
</h1>
<p>12 August 2019</p>
<h2 id="written-down-notes">Written down notes</h2>
<ul>
  <li>useEffect runs after every render</li>
  <li>Only call hooks from top level (not from within loops, etc.).</li>
  <li>
    <strong>Watch out</strong> once a hook gets triggered, the functional
    component re-renders (also it’s children).
  </li>
  <li>
    useEffect gets triggered after render and after the DOM render (after the
    paint phase).
  </li>
  <li>
    componentDidMount and componentDidUpdate actually blocks the browser from
    updating the screen
  </li>
  <li>
    useLayoutEffect =&gt; use this if you want synchronous effects (before the
    DOM paint phase).
  </li>
  <li>
    effects run after every render and not just once. React also cleans up every
    effect!
  </li>
  <li>
    Every time you use a custom hook, all state. and effect inside the hook are
    fully isolated
  </li>
  <li>
    ** Mutations, subscriptions, timers, logging and all other side effects are
    NOT allowed inside the main body of a function component **
  </li>
  <li>useRef: helpful for keeping any mutable value around.</li>
  <li>useRef: mutating it does NOT cause a re-render.</li>
  <li>
    do not reference functions inside a useEffect, that are declared outside a
    useEffect. This makes it easy to introduce bugs, because they could
    reference state or props that has not been defined in the depencies of that
    useEffect.
  </li>
  <li>
    React.Memo is the equivalent to React.PureComponent.
    <strong
      >write your code so that it works without useMemo, only after that add
      it</strong
    >. Because React could change stuff in the future, also for decoupling
    (orthogonality).
  </li>
  <li>Lazily intialize a ref.</li>
  <li>
    useState(() =&gt; {}), this way it is only called once during the first
    render, otherwise if you have a calculation, it can be run every render.
  </li>
  <li><strong>Avoid passing callback deep down!</strong></li>
  <li>
    Prevent setting state fro unmounted components!
    <strong>as with async api calls eg</strong>
  </li>
</ul>
<h2 id="coming-back-to-react-after-a-while">
  Coming back to React after a while
</h2>
<p>
  At work, I did an Angular project for about 4 months. To find out how that
  was, check my previous blog post. I left the React world back in February,
  just when hooks were new. When returning to React, I thought i knew them. Oh
  boy was I wrong.
</p>
<p>I was toying around with a location service and had something like this:</p>
<pre><code>const location = useLocation();</code></pre>
<p>
  I put a console.log in my function component and the thing triggered multiple
  times. I had no idea what was going on. I blamed it on the npm package with
  ‘not that many stars’ and picked another one.
</p>
<p>
  After that i encountered some <code>exceeded call stack</code> errors. I
  figured it was time to study React hooks again.
</p>
<p>Lessons learned in a nutshell:</p>
<ul>
  <li>
    Hooks trigger a re-render! When state changes, the whole body of the
    function component gets run and rendered again. Never thought about it, but
    makes sense. Since there is no <code>render()</code> method in a function
    component, the whole code gets run, and not only the
    <code>return &lt;JSX&gt;</code>
  </li>
  <li>
    useEffect gets triggered after a render and
    <strong>after a DOM update</strong> (after paint phase). React also cleans
    up every useEffect after render!
  </li>
  <li>
    <code>componentDidMount</code> or <code>componentDidUpdate</code> blocks the
    browser from updating the screen! Unlike useEffect. If you want synchronous
    effects, use <code>useLayoutEffect</code>
  </li>
  <li>
    Every time you use a custom hook, all state and effects inside of it are
    fully isolated!
    <strong
      >Two components using the same hook, do not share the same state</strong
    >
  </li>
  <li>
    Mutations, subscriptions, timers, logging
    <strong>and all other side effects</strong> are NOT allowed inside the main
    body of a function component.
  </li>
  <li>
    <code>useRef</code> is useful for keeping any mutable value around. Similar
    to how you’d use instance fields in classes. Mutating useRef does NOT cause
    a re-render.
  </li>
  <li>
    Do not reference functions declared outside a useEffect hook. This makes it
    easy to introduce bugs. I could reference state or props that has not been
    defined in the depencies of that useEffect.
  </li>
  <li>
    <code>React.Memo</code> is the equivalent to
    <code>React.PureComponent</code>.
    <strong>write your code so that it works without useMemo</strong>, only
    after that add it. Because React could change stuff in the future, also for
    orthogonality.
  </li>
  <li>
    <code>useState(() =&gt; {})</code>, this way the initial state is only
    called once during the first render. This is meant for
    <code>useState(someHeavyCalculationThatReturnsMyInitialState())</code>
  </li>
  <li>
    use <code>useReducer</code> without Redux. For state calculations with
    e.g. API calls.
  </li>
  <li>Avoid passing callbacks deep down!</li>
  <li>
    Avoid setting state on unmounted components. This can happen with e.g. API
    calls inside a <code>useEffect</code>
  </li>
</ul>
<h2 id="sources">Sources</h2>
<p>
  Everything in the offical docs ❤️. https://reactjs.org/docs/hooks-intro.html
  Api call useEffect snippet. https://codesandbox.io/s/jvvkoo8pq3 Data fechting
  blog post on hooks by Robin Wieruch.
  https://www.robinwieruch.de/react-hooks-fetch-data/
</p>
